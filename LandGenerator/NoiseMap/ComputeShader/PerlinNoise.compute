// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel calculatePerlin
#ifndef __noise_hlsl_
#define __noise_hlsl_

struct vertex
{
    float x;
    float y;
    float z;
};

RWStructuredBuffer<vertex> OutVertex;
RWStructuredBuffer<biom> inBiom;

int biomsCount;
int vertexPerLine;
float vertexDistance;
float generalMultiplier;
float3 initialPosition;
float2 offset;


// hash based 3d value noise
// function taken from https://www.shadertoy.com/view/XslGRr
// Created by inigo quilez - iq/2013
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

// ported from GLSL to HLSL

float hash( float n )
{
    return frac(sin(n)*43758.5453);
}

float noise( float3 x )
{
    // The noise function returns a value in the range -1.0f -> 1.0f

    float3 p = floor(x);
    float3 f = frac(x);

    f       = f*f*(3.0-2.0*f);
    float n = p.x + p.y*57.0 + 113.0*p.z;

    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),
                   lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),
               lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
                   lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
}

#endif


[numthreads(64,1,1)]
void calculatePerlin (uint3 id : SV_DispatchThreadID)
{
    int id_X = id.x % vertexPerLine;
    int id_Z = trunc(id.x / vertexPerLine);
    float vertex_X = initialPosition[0] + (id_X * vertexDistance);
    float vertex_Z = initialPosition[2] + (id_Z * vertexDistance);
    float3 punto = float3(vertex_X + offset[0], 0, vertex_Z + offset[1]);

    float vertexHeight = noise(punto) * generalMultiplier;

    vertex newVertex;
    newVertex.x = vertex_X;
    newVertex.y = vertexHeight;
    newVertex.z = vertex_Z;

    OutVertex[id.x] = newVertex;
}